# TX面试

## 初试：

### c和c++有什么不同

- c是面向对象的，c++是面向过程的
- c++提供了类，虚类，虚继承，模版等多种方式，使用c++既可以用面向对象的方式编程，也可以面向过程的方式编程

### 为什么要用到extern “C”

- c和c++编译后的符号修饰名称不一样。

  - c中的函数签名，经过符号修饰后，会在前面加上_。例如：foo => _foo
  - c++中的函数签名，经过符号修饰后，会加上空间名，类名，函数名，函数参数等信息。（具体见《程序员自我修养》）例如：N::C::func(int) => _ZN1N1C4funcEi

- 在年代比较久远的时间段，库是用c编译的，库中的链接名称按照c的标准。但是，如果是用c++标准，相同的函数名，符号修饰后的名称不同，因此会出现未定义的情况，使用extern “C”，才能够正确使用。

- 如果想将c++的函数编译成c的格式，需要使用extern “C”修饰整段代码。

  （**PS：c中不允许使用extern “C”，因此需要加上宏定义#ifndef __cplusplus**）

### c++怎么实现多态

- 通过virtual关键字实现，详细请见另一篇：**C语言中类和虚类有关问题**

### inline关键字的优缺点是什么，可以递归自己吗

- 优点：将函数代码直接嵌入到调用处，节省了函数调用的时候寄存器修改和压栈的时间和空间
- 缺点：
  1. 函数代码直接替换，会使代码段变得冗长
  2. 当某项目文件链接使用inline函数的代码库时，代码库修改后，由于是inline关系，项目必须要重新编译才能进行链接
  3. 由于编译器会对inline函数进行替换，inline函数必须在调用前定义，不能只有声明，没有定义。
- inline只是对编译器提供一个建议，具体是否采用这个建议需要编译器自己做决定。因此，如果在inline函数中使用递归自己，编译器可能不会采用这个建议。

### volatile关键字有什么作用，能和const共用吗，能用于指针吗

- volatile关键字用于修饰变量，被volatile修饰的变量，编译器会执行两个操作：

  1. 编译起不会再对其他访问该变量的相关代码进行优化，保证原子性。
  2. 使用该值的时候，将从内存读值，而不会从寄存器里面读该值。

  （**PS：可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象**）

- volatile可以和const共用，而且也有必要和const共用。因为const修饰的变量虽然不能被进程内操作改变，但是可以被进程外操作改变，因此volatile和const共同修饰一个变量是有必要的。

- volatile可以用于指针，而且也有必要用于指针。当修饰的变量是函数指针或者字符串变量的时候，就可以使用volatile修饰指针。

### c++的new关键字原理是什么，重载new关键字可能出现的问题是什么，delete和delete[]的区别是什么

- 我们平常使用的new关键字实际上是new operator，不能被重载，它分为三个部分：

  1. 声明内存空间 => operator new
  2. 在声明的内存空间中调用类的构造函数 => placement new
  3. 将指针转换成指定类型返回

  我们重载的部分实际上是第一个部分，即operator new，用来声明内存空间。

  如果调用失败，程序会执行new_handle函数，如果该函数抛出bad_alloc，函数终止。

- 重载new可能出现的问题：

  1. 假设有一个全局变量count记录类实例数量，new声明新对象的时候，将count++。但是声明新对象并没有成功，抛出bac_alloc终止。此时count数量就和实例数量不匹配了。
  2. 子类没有new函数，会调用基类的new，会导致声明的空间过小。

- 简单来说，delete只执行一次析构函数，delete[]执行多次析构函数，因此对没有析构函数的类型，delete和delete[]没有区别。

### 什么是操作系统的硬中断和软中断

- 硬中断：硬中断是由与系统相连的外设（网卡，硬盘）自动产生的，是外部设备发给CPU的中断。CPU在接收中断后，会中断正在运行的任务，来处理中断。**如果该中断较长，可以被抢占。**
- 软中断：软中断的处理方式和硬中断类似，但是软中断是由当前运行的所产生的进程。通常，软中断是对一些IO的请求。

### 介绍一下tcp三次握手和四次挥手

- 见图

  ![](photo/三次握手.png)

  ![](photo/四次挥手.png)

## 复试：

### 类的this指针存储在什么地方

- 函数调用时，this指针存储在ecx**寄存器**上，通过ecx传递给调用者，此时函数调用约定是\_thiscall。若参数个数不确定（可变参数）时，则借助栈，在所有的参数被压栈后，再压入栈中，此时函数调用约定是\_cdecl。

###c++11的move特性是什么

> 参考链接：https://www.cnblogs.com/ldlchina/p/6608154.html

- 说这一点前，需要先说明什么是左值，什么是右值，简单说左值可以赋值，右值不可以赋值。以下面代码为例，“ A a = getA();”该语句中a是左值，getA()的返回值是右值。

- 移动构造函数：类似拷贝构造函数，不进行深度构造，定义如下。

  ```c++
  A(const A&&) { std::cout << "Move Constructor" << std::endl; }
  ```

- 但是"A a1(a)"仍然是拷贝构造，但是"A a2(std::move(a))"可以将a移动为右值，然后使用移动构造，而不使用拷贝构造。

### Mongodb数据库和mysql数据库的区别在哪

- mongodb数据库是基于分布式文件系统的非关系型Key-Value数据库，mysql是关系型数据库。
- mongodb只有库级锁，基本不支持事务操作，mysql有很好的事务回滚恢复操作。
- mongodb速度较快，mysql速度比较慢
- mongodb不支持关系复杂的聚合类型，比如外键之类，mysql可以很好的处理这些

### c#怎么调用c++类函数

> 参考链接：https://www.cnblogs.com/profession/p/5852458.html

- 新封装一个c#类，其中包含c++类头文件，而且封装了所有c++类中的public函数
- c#类中包含c++类指针
- 函数实现时，c#特殊类型转换成c++类型即可